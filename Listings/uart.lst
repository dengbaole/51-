C51 COMPILER V9.54   UART                                                                  11/04/2022 18:18:39 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN .\Objects\uart.obj
COMPILER INVOKED BY: D:\app\keil51\C51\BIN\C51.EXE user\uart.c COMPACT OPTIMIZE(8,SPEED) BROWSE INCDIR(.\user;D:\app\kei
                    -l51\C51\INC\Atmel) DEBUG OBJECTEXTEND PRINT(.\Listings\uart.lst) TABS(2) OBJECT(.\Objects\uart.obj)

line level    source

   1          #include "uart.h"
   2          #include <REGX52.H>
   3          
   4          unsigned char code recv_correct[] = {0x55,0xAA,0x80,0x0,0x80,0x80};
   5          unsigned char code sum_check_error[] = {0x55,0xAA,0x81,0x0,0x81,0x81};
   6          unsigned char code xor_check_error[] = {0x55,0xAA,0x82,0x0,0x82,0x82};
   7          unsigned char recv_buf[MAX_REV_NUM];
   8          unsigned char recv_cnt = 0;
   9          unsigned char recv_flag = 0;
  10          unsigned char machine_stap = 0;
  11          unsigned int led_data;
  12          unsigned int led_cnt;
  13          unsigned int beep_data;
  14          unsigned int beep_cnt;
  15          unsigned char recv_length;
  16          
  17          void uart_init(void)   //4800bps@12.000MHz
  18          {
  19   1          SCON = 0x50;        //æ¥æ”¶ä½¿èƒ½
  20   1          PCON |= 0x80;   //ä½¿èƒ½æ³¢ç‰¹ç‡å€é€Ÿä½SMOD
  21   1      
  22   1      
  23   1          //å®šæ—¶å™¨é…ç½®ï¼ˆç”¨ä½œæ³¢ç‰¹ç‡å‘ç”Ÿå™¨ï¼‰
  24   1          TMOD = TMOD & 0x0F;   //ä½å››ä½æ¸…é›¶ï¼Œé«˜å››ä½ä¸å˜
  25   1          TMOD = TMOD | 0x20;   //å®šæ—¶å™¨æ¨¡å¼é…ç½®
  26   1          //èµ‹åˆå€¼å’Œæ³¢ç‰¹ç‡æœ‰å…³
  27   1          TL1 = 0xF3;   //è®¾å®šå®šæ—¶åˆå€¼
  28   1        TH1 = 0xF3;   //è®¾å®šå®šæ—¶å™¨é‡è£…å€¼
  29   1      
  30   1          //ä¸­æ–­é…ç½®
  31   1          ET1 = 0;       //ç¦ç”¨å®šæ—¶å™¨1ä¸­æ–­
  32   1          TR1 = 1;       //å¯åŠ¨å®šæ—¶å™¨1
  33   1      
  34   1          EA = 1;
  35   1          ES = 1;
  36   1      }
  37          
  38          //å‘é€1å­—èŠ‚æ•°æ®
  39          void UART_SendByte(unsigned char Byte)
  40          {
  41   1          SBUF=Byte;    //æŠŠæ•°æ®å†™åˆ°ç¼“å†²å™¨ä¸­ï¼Œè‡ªåŠ¨å‘é€ç»™ç”µè„‘
  42   1          while(TI==0);
  43   1          TI=0;         //æ ‡å¿—ä½éœ€è¦è½¯ä»¶å¤ä½
  44   1      }
  45          
  46          //æ‰“å°å­—ç¬¦ä¸²
  47          void UART_SendString(unsigned char *buf)
  48          {
  49   1          while (*buf != '\0')
  50   1          {
  51   2              UART_SendByte(*buf++);
  52   2          }
  53   1      }
  54          
C51 COMPILER V9.54   UART                                                                  11/04/2022 18:18:39 PAGE 2   

  55          //printfé‡å®šå‘
  56          char putchar(char c)
  57          {
  58   1          UART_SendByte(c);
  59   1          return c;
  60   1      }
  61          
  62          void clr_recvbuffer(unsigned char *buf)
  63          {
  64   1          unsigned char i;
  65   1          for(i=0;i<MAX_REV_NUM;i++)
  66   1          {
  67   2              buf[i]=0;
  68   2          }
  69   1      }
  70          
  71          // //æ¥æ”¶æ•°æ®å¤„ç†å‡½æ•°
  72          // void uart_service(unsigned char *buf)
  73          // {
  74          //     unsigned char recv_move_indev;
  75          //     if(recv_flag)
  76          //     {
  77          //         recv_flag = 0;
  78          //         start_timer = 0;
  79                
  80          //         //æ¥æ”¶çš„æ•°æ®è¦å¤§äº5ä¸ªå­—èŠ‚(åŒ…å¤´ï¼Œåœ°å€ï¼Œæ•°æ®ç±»å‹ï¼Œæ•°æ®ï¼Œæ ¡éªŒ)ï¼Œ
  81          //         while((recv_cnt>=5)&&(recv_move_indev<=recv_cnt))
  82          //         {
  83          //             //åˆ¤æ–­åŒ…å¤´åœ°å€æ•°æ®ç±»å‹
  84          //             if((buf[recv_move_indev+0]==0x55)&&(buf[recv_move_indev+1]==0xAA)&&(buf[recv_move_indev+2]=
             -=0x55))
  85          //             {
  86          //                 if((buf[recv_move_indev+3]==0x01)&&(buf[recv_move_indev+4]==0x02))
  87          //                 {
  88          //                     printf("11111111111111111111\n");     //æ¥æ”¶åˆ°æ•°æ®{0x55 0xaa 0x55 0x01 0x02}äº
             -®ç¯
  89          //                     P2_1 = 0;
  90          //                 }
  91          //                 if((buf[recv_move_indev+3]==0x02)&&(buf[recv_move_indev+4]==0x03))
  92          //                 {
  93          //                     printf("2222222222222222222\n");      //æ¥æ”¶åˆ°æ•°æ®{0x55 0xaa 0x55 0x02 0x03}ç
             -­ç¯
  94          //                     P2_1 = 1;
  95          //                 }
  96          //                 break;   //æŸ¥æ‰¾æˆåŠŸå¹¶æ‰§è¡Œåˆ¤æ–­åé€€å‡ºå¾ªç¯
  97          //             }
  98          //             recv_move_indev++;
  99          //         }
 100          //         UART_SendString(recv_buf);    //æ‰“å°æ¥æ”¶åˆ°çš„æ•°æ®
 101          //         clr_recvbuffer(recv_buf);     //æ¸…é™¤ç¼“å†²buff
 102          //         recv_cnt = 0;
 103          //     }
 104          // }
 105          
 106          
 107          
 108          
 109          //ä¸­æ–­å‡½æ•°åç§°è‡ªå®šä¹‰ï¼Œå‡½æ•°åé¢åŠ ä¸­æ–­å·
 110          void UART_ISR() interrupt 4
 111          {
 112   1          unsigned char i;
 113   1          unsigned char recv_data;   //æ•°æ®ç¼“å†²åŒº
C51 COMPILER V9.54   UART                                                                  11/04/2022 18:18:39 PAGE 3   

 114   1          static unsigned char sum_check;   //æ ¡éªŒå’Œ
 115   1          static unsigned char xor_check;   //oræ ¡éªŒ
 116   1          //åˆ¤æ–­æ˜¯å¦æ˜¯æ¥æ”¶ä¸­æ–­
 117   1          if(RI)
 118   1          {
 119   2              RI = 0;
 120   2              recv_data = SBUF;
 121   2              switch(machine_stap)
 122   2              {
 123   3                  //åˆ¤æ–­åŒ…å¤´æ˜¯å¦æ˜¯ 0x55 0xAA
 124   3                  case 0: 
 125   3                      if(recv_data==0x55)
 126   3                      {
 127   4                          machine_stap = 1;
 128   4                      }   
 129   3                      else
 130   3                      {
 131   4                          machine_stap = 0;
 132   4                      }
 133   3                      break;
 134   3                  case 1: 
 135   3                      if(recv_data == 0xAA)
 136   3                      {
 137   4                          machine_stap = 2;
 138   4                          recv_cnt = 0;
 139   4                      }
 140   3                      else
 141   3                      {
 142   4                          machine_stap = 0;
 143   4                      }
 144   3                      break;
 145   3                  case 2:
 146   3                      //æ ¡éªŒå’Œï¼ˆåœ°å€å¼€å§‹è®¡ç®—ï¼‰
 147   3                      sum_check = recv_data;
 148   3                      //xoræ ¡éªŒ
 149   3                      xor_check = recv_data;
 150   3                      recv_buf[recv_cnt] = recv_data;   //æ•°æ®ç±»å‹
 151   3                      recv_cnt++;
 152   3                      machine_stap = 3;
 153   3                      break;
 154   3                  case 3:
 155   3                      //æ ¡éªŒå’Œï¼ˆåœ°å€å¼€å§‹è®¡ç®—ï¼‰
 156   3                      sum_check += recv_data;
 157   3                      //xoræ ¡éªŒ
 158   3                      xor_check ^= recv_data;
 159   3                      recv_length = recv_data;
 160   3                      machine_stap = 4;
 161   3                      break;
 162   3                  case 4:
 163   3                      //æ ¡éªŒå’Œï¼ˆåœ°å€å¼€å§‹è®¡ç®—ï¼‰
 164   3                      sum_check += recv_data;
 165   3                      //xoræ ¡éªŒ
 166   3                      xor_check ^= recv_data;
 167   3                      recv_buf[recv_cnt] = recv_data;   //å…·ä½“æ•°æ®
 168   3                      if(recv_cnt==recv_length)
 169   3                      {
 170   4                          machine_stap = 5;
 171   4                      }
 172   3                      else
 173   3                      {
 174   4                          machine_stap = 4;
 175   4                      }
C51 COMPILER V9.54   UART                                                                  11/04/2022 18:18:39 PAGE 4   

 176   3                      recv_cnt++;
 177   3                      break;
 178   3                  case 5:      
 179   3                      //å’Œæ ¡éªŒæ˜¯å¦æ­£ç¡®
 180   3                      if(sum_check == recv_data)
 181   3                      {
 182   4                          machine_stap = 6;
 183   4                      }
 184   3                      else
 185   3                      {
 186   4                          recv_flag = 1;
 187   4                          machine_stap = 0;
 188   4                          for(i = 0;i<6;i++)
 189   4                          {
 190   5                              UART_SendByte(sum_check_error[i]);
 191   5                          }
 192   4                      }
 193   3                      break;
 194   3                  case 6:
 195   3                      //xoræ ¡éªŒæ­£ç¡®
 196   3                      if(xor_check == recv_data)
 197   3                      {
 198   4                          recv_flag = 1;  //æ¥æ”¶åˆ°ä¸€å¸§æ­£ç¡®æ•°æ®æ ‡å¿—
 199   4                          for(i = 0;i<6;i++)
 200   4                          {
 201   5                              UART_SendByte(recv_correct[i]);
 202   5                          }
 203   4                      }
 204   3                      else
 205   3                      {
 206   4                          recv_flag = 1;
 207   4                          for(i = 0;i<6;i++)
 208   4                          {
 209   5                              UART_SendByte(xor_check_error[i]);
 210   5                          }
 211   4      
 212   4                          //é”™è¯¯åº”ç­”
 213   4                      }
 214   3                      machine_stap = 0;
 215   3                      recv_cnt = 0;
 216   3                      sum_check = 0;
 217   3                      xor_check = 0;
 218   3                   
 219   3                      break;
 220   3                  default:
 221   3                      break;
 222   3              }
 223   2          }
 224   1          // //å‘é€æ•°æ®ä¸­æ–­
 225   1          // if(TI)
 226   1          // {
 227   1          //     TI=0;
 228   1          // }
 229   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    447    ----
   CONSTANT SIZE    =     18    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =     24       6
   DATA SIZE        =   ----    ----
C51 COMPILER V9.54   UART                                                                  11/04/2022 18:18:39 PAGE 5   

   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
