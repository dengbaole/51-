C51 COMPILER V9.54   UART                                                                  10/26/2022 21:15:53 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN .\Objects\uart.obj
COMPILER INVOKED BY: D:\app\keil51\C51\BIN\C51.EXE user\uart.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\user;D:\app\keil51\C51\
                    -INC\Atmel) DEBUG OBJECTEXTEND PRINT(.\Listings\uart.lst) TABS(2) OBJECT(.\Objects\uart.obj)

line level    source

   1          #include "uart.h"
   2          #include <REGX52.H>
   3          
   4          
   5          unsigned char recv_buf[MAX_REV_NUM];
   6          unsigned char recv_cnt = 0;
   7          unsigned char recv_length;
   8          unsigned char start_timer=0;
   9          unsigned char recv_timer_cnt;
  10          unsigned char recv_flag = 0;
  11          
  12          void uart_init(void)   //4800bps@12.000MHz
  13          {
  14   1          SCON = 0x50;        //æ¥æ”¶ä½¿èƒ½
  15   1          PCON |= 0x80;   //ä½¿èƒ½æ³¢ç‰¹ç‡å€é€Ÿä½SMOD
  16   1      
  17   1      
  18   1          //å®šæ—¶å™¨é…ç½®ï¼ˆç”¨ä½œæ³¢ç‰¹ç‡å‘ç”Ÿå™¨ï¼‰
  19   1          TMOD = TMOD & 0x0F;   //ä½å››ä½æ¸…é›¶ï¼Œé«˜å››ä½ä¸å˜
  20   1          TMOD = TMOD | 0x20;   //å®šæ—¶å™¨æ¨¡å¼é…ç½®
  21   1          //èµ‹åˆå€¼å’Œæ³¢ç‰¹ç‡æœ‰å…³
  22   1          TL1 = 0xF3;   //è®¾å®šå®šæ—¶åˆå€¼
  23   1        TH1 = 0xF3;   //è®¾å®šå®šæ—¶å™¨é‡è£…å€¼
  24   1      
  25   1          //ä¸­æ–­é…ç½®
  26   1          ET1 = 0;       //ç¦ç”¨å®šæ—¶å™¨1ä¸­æ–­
  27   1          TR1 = 1;       //å¯åŠ¨å®šæ—¶å™¨1
  28   1      
  29   1          EA = 1;
  30   1          ES = 1;
  31   1      }
  32          
  33          //å‘é€1å­—èŠ‚æ•°æ®
  34          void UART_SendByte(unsigned char Byte)
  35          {
  36   1          SBUF=Byte;    //æŠŠæ•°æ®å†™åˆ°ç¼“å†²å™¨ä¸­ï¼Œè‡ªåŠ¨å‘é€ç»™ç”µè„‘
  37   1          while(TI==0);
  38   1          TI=0;         //æ ‡å¿—ä½éœ€è¦è½¯ä»¶å¤ä½
  39   1      }
  40          
  41          //æ‰“å°å­—ç¬¦ä¸²
  42          void UART_SendString(unsigned char *buf)
  43          {
  44   1          while (*buf != '\0')
  45   1          {
  46   2              UART_SendByte(*buf++);
  47   2          }
  48   1      }
  49          
  50          //printfé‡å®šå‘
  51          char putchar(char c)
  52          {
  53   1          UART_SendByte(c);
  54   1          return c;
C51 COMPILER V9.54   UART                                                                  10/26/2022 21:15:53 PAGE 2   

  55   1      }
  56          
  57          void clr_recvbuffer(unsigned char *buf)
  58          {
  59   1          unsigned char i;
  60   1          for(i=0;i<MAX_REV_NUM;i++)
  61   1          {
  62   2              buf[i]=0;
  63   2          }
  64   1      }
  65          
  66          //æ¥æ”¶æ•°æ®å¤„ç†å‡½æ•°
  67          void uart_service(unsigned char *buf)
  68          {
  69   1          unsigned char recv_move_indev;
  70   1          if(recv_flag)
  71   1          {
  72   2              recv_flag = 0;
  73   2              start_timer = 0;
  74   2            
  75   2              //æ¥æ”¶çš„æ•°æ®è¦å¤§äº5ä¸ªå­—èŠ‚(åŒ…å¤´ï¼Œåœ°å€ï¼Œæ•°æ®ç±»å‹ï¼Œæ•°æ®ï¼Œæ ¡éªŒ)ï¼Œ
  76   2              while((recv_cnt>=5)&&(recv_move_indev<=recv_cnt))
  77   2              {
  78   3                  //åˆ¤æ–­åŒ…å¤´åœ°å€æ•°æ®ç±»å‹
  79   3                  if((buf[recv_move_indev+0]==0x55)&&(buf[recv_move_indev+1]==0xAA)&&(buf[recv_move_indev+2]==0x
             -55))
  80   3                  {
  81   4                      if((buf[recv_move_indev+3]==0x01)&&(buf[recv_move_indev+4]==0x02))
  82   4                      {
  83   5                          printf("11111111111111111111\n");     //æ¥æ”¶åˆ°æ•°æ®{0x55 0xaa 0x55 0x01 0x02}äº®ç
             -¯
  84   5                          P2_1 = 0;
  85   5                      }
  86   4                      if((buf[recv_move_indev+3]==0x02)&&(buf[recv_move_indev+4]==0x03))
  87   4                      {
  88   5                          printf("2222222222222222222\n");      //æ¥æ”¶åˆ°æ•°æ®{0x55 0xaa 0x55 0x02 0x03}ç­ç
             -¯
  89   5                          P2_1 = 1;
  90   5                      }
  91   4                      break;   //æŸ¥æ‰¾æˆåŠŸå¹¶æ‰§è¡Œåˆ¤æ–­åé€€å‡ºå¾ªç¯
  92   4                  }
  93   3                  recv_move_indev++;
  94   3              }
  95   2              UART_SendString(recv_buf);    //æ‰“å°æ¥æ”¶åˆ°çš„æ•°æ®
  96   2              clr_recvbuffer(recv_buf);     //æ¸…é™¤ç¼“å†²buff
  97   2              recv_cnt = 0;
  98   2          }
  99   1      }
 100          
 101          
 102          
 103          
 104          //ä¸­æ–­å‡½æ•°åç§°è‡ªå®šä¹‰ï¼Œå‡½æ•°åé¢åŠ ä¸­æ–­å·
 105          void UART_ISR() interrupt 4
 106          {
 107   1          
 108   1          //åˆ¤æ–­æ˜¯å¦æ˜¯æ¥æ”¶ä¸­æ–­
 109   1          if(RI)
 110   1          {
 111   2              RI = 0;
 112   2              start_timer=1;                      //å¯åŠ¨è®¡æ•°å™¨
 113   2              //åˆ¤æ–­æ˜¯å¦æ˜¯ç»“æŸç¬¦
C51 COMPILER V9.54   UART                                                                  10/26/2022 21:15:53 PAGE 3   

 114   2              if(recv_cnt<MAX_REV_NUM)
 115   2              {
 116   3                  recv_buf[recv_cnt++] = SBUF;   //æ¥æ”¶åˆ°çš„æ•°æ®æ”¾å¤§ç¼“å†²åŒº
 117   3              }
 118   2              else
 119   2              {
 120   3                  recv_cnt=MAX_REV_NUM;
 121   3              }
 122   2              recv_timer_cnt = 0;               //æ¥æ”¶å®Œä¸€å¸§æ•°æ®åï¼Œå®šæ—¶å™¨è®¡æ•°æ¸…é›¶
 123   2          }
 124   1          // //å‘é€æ•°æ®ä¸­æ–­
 125   1          // if(TI)
 126   1          // {
 127   1          //     TI=0;
 128   1          // }
 129   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    361    ----
   CONSTANT SIZE    =     43    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     15      10
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
